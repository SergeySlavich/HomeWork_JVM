Описание работы Java Virtual Machine.

Для начала программа должна быть создана. Готовый файл программы - файл с расширением .java компилируется в байт-код,
 файл, с расширением .class. А затем этот байт-код передается в Java Virtual Machine (JVM).
 JVM и занимается непосредственно выполнением программы. В функции JVM входит организация ресурсов устройства,
 обеспечение выполнения программы на том устройстве, на котором установлена JVM.

При запуске виртуальной машины Java, выделяется память для работы: стек, heap, metaspace.
Стек - основная рабочая область памяти. Именно в стек загружаются выполняемые кадры программы, и выгружаются из него по мере выполнения.
Metaspace - область памяти для хранения информации о классе: имя, константы, методы.
Heap - область памяти для хранения данных ссылочного типа.

После запуска приложения JVM определяет классы для загрузки. В нашем случае это класс JvmComprehension и класс System.
Модуль JVM, называемый ClassLoader, выполняет загрузку информации о классax JvmComprehension и System в metaspace.
ClassLoader состоит из трех уровней: Application ClassLoader, Platform ClassLoader и Bootstrap ClassLoader.
 Запрос на загрузку классов принимает Application ClassLoader, передает на уровень Platform ClassLoader, а тот - на уровень Bootstrap ClassLoader.
 Bootstrap ClassLoader ищет информацию о классах и загружает их в Metaspace, если находит. Если не находит, передает на уровень Platform ClassLoader.
 На этом уровне так же осуществляется поиск еще не найденных классов, которые загружаются в Metaspace, если Platform ClassLoader их находит.
 Если и он не находит, то поиск осуществляет уже Aplication ClassLoader. И если этот ClassLoader не находит нужного класса, выбрасывается исключение
 NotClassFoundException. В нашем случае класс System будет загружен на уровне Bootstrap, а класс JvmComprehension будет загружен на уровне Application.

Выполнение программы начинается с метода main. В стеке создается кадр метода main.
 В этот кадр записываются все локальные переменные этого метода.
 В рассматриваемой программе это 3 переменные: целочисленная int записывается вместе со значением 1. (строка с пометкой //1)
 Ссылочная типа Object под именем o и типа Integer под именем ii. (строки //2 и //3)
 Вместо значений в кадре записываются адреса ссылок в области памяти Heap, где хранятся их фактические значения.

Следующая строка - это метод printAll. Записывается следующим кадром в стеке. (строка //4)
 Аргументы этого метода так же записываются в этом же кадре, но адреса ссылок соответствуют тем же адресам в heap, что и в методе main.
 Ещё создается локальная переменная типа Integer под именем uselessVar со значением в виде адреса на фактическое значение "700",
 записываемое в области heap.

Следующая строка программы (строка //6) вызовет создание еще одного кадра в стеке. В этом кадре будут записаны аргументы o, i, ii,
 которые будут ссылаться на уже созданные значения в памяти heap и на переменную i в стеке, в кадре main.
 "o.toString()" вызовет создание еще одного кадра в стеке. Кадр метода, преобразующего информацию из области heap по адресу "o", в информацию типа "String".
 После выполнения этого кадра, и получения результата, последний будет записан в heap. После чего этот кадр будет удален из стека.

Будет продолжена работа с кадром System.out.println(). Произойдет обработка результата предыдущего кадра с переменной i, хранящейся в стеке, в кадре main, и переменной ii,
 значение которой хранится в heap. Результат суммирования этих трех переменных будет выведен в консоль, после чего и этот кадр будет удален из стека.

Кадр "printAll" так же будет удален следующим, так как он будет завершен.

По порядку работы в обработку снова попадет кадр main. Будет вызван метод System.out.println(), а значит, в стеке будет снова создан новый кадр.
 После того, как в консоль будет выведено слово "finished" (строка //7) и этот кадр будет закрыт, снова откроется кадр main. Так как там всё уже выполнено,
 то и кадр main будет удален из стека. Стек освободится.

В процессе работы JVM будет приостанавливать работу программ для запуска "Сборщика мусора" (Garbage collector). 
 Сборщик мусора проверит область памяти heap на наличие ячеек памяти, которые не вызывались.
 При обнаружении, уничтожит хранящиеся там данные для освобождения памяти.


public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}